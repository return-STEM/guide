{"pageProps":{"courseData":{"href":"introcpp","difficulty":"Beginner","name":"Introduction to C++"},"walkthroughData":{"lessons":[{"name":"Introduction","href":"introduction"},{"name":"Variables and Data Types","href":"variables"},{"name":"Console I/O","href":"consoleio"},{"name":"Arithmetic Operations","href":"arithmetic"},{"name":"Control Structures: Conditionals","href":"conditionals"},{"name":"Control Structures: Loops","href":"loops"},{"name":"Arrays","href":"arrays"},{"name":"Functions","href":"functions"},{"name":"C++ Standard Library (STL)","href":"cppstandardlibrary"},{"name":"Debugging","href":"debugging"}],"wipLessons":[]},"lessonData":{"name":"C++ Standard Library (STL)","href":"cppstandardlibrary"},"mdContent":{"compiledSource":"var h=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(a,t,n)=>t in a?h(a,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):a[t]=n,e=(a,t)=>{for(var n in t||(t={}))i.call(t,n)&&l(a,n,t[n]);if(o)for(var n of o(t))r.call(t,n)&&l(a,n,t[n]);return a},p=(a,t)=>d(a,m(t));var c=(a,t)=>{var n={};for(var s in a)i.call(a,s)&&t.indexOf(s)<0&&(n[s]=a[s]);if(a!=null&&o)for(var s of o(a))t.indexOf(s)<0&&r.call(a,s)&&(n[s]=a[s]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var s=n,{components:a}=s,t=c(s,[\"components\"]);return mdx(MDXLayout,p(e(e({},layoutProps),t),{components:a,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"In the previous lessons, we learned about the various features of the C++ standard. However, that's not all there is that makes C++ so powerful. C++ as a language is implemented via the compiler that translates your code into machine language. There is also a C++ standard that determines exactly how this works, along with various features that should be implemented in a standard library.\"),mdx(\"p\",null,\"This standard library comes with C++ code that implements various useful features. We have already worked with some of them, like \",mdx(\"inlineCode\",{parentName:\"p\"},\"cout\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"cin\"),\". In this lesson, we will explore various other features of the standard library as well as give you the tools to learn whatever you need.\"),mdx(\"h1\",e({},{id:\"prerequisites\"}),\"Prerequisites\"),mdx(\"p\",null,\"Before diving into the C++ standard library, there are a few more advanced features of the C++ language we have to quickly go over. The first of these is a \",mdx(\"inlineCode\",{parentName:\"p\"},\"class\"),\" which is something we have worked with before. A class is a user-defined data structure that contains data and functions. A class is a sort of blueprint that can be used to create \",mdx(\"strong\",{parentName:\"p\"},\"objects\"),\" of that class. \"),mdx(\"h2\",e({},{id:\"classes\"}),\"Classes\"),mdx(\"p\",null,\"Let's try an example. Let's say we have a class for a \",mdx(\"inlineCode\",{parentName:\"p\"},\"Car\"),\". The class stores various data points like the make, max speed, and cost. The class also has functions like \",mdx(\"inlineCode\",{parentName:\"p\"},\"drive()\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"park()\"),\", and more. Now we could declare a variable of the class \",mdx(\"inlineCode\",{parentName:\"p\"},\"Car\"),\". Objects typically have a special function called a \",mdx(\"inlineCode\",{parentName:\"p\"},\"constructor\"),\" which allows us to pass arguments to the object upon creation that can do things like set data values. So we could use the constructor to set a specific make and other various details.\"),mdx(\"p\",null,\"We treat classes pretty much the same as a data type like \",mdx(\"inlineCode\",{parentName:\"p\"},\"int\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},\"bool\"),\", except they come with a few extra features. Classes are useful organizational structures like functions and can be quite powerful. They help us generalize and abstract code in such a way that allows us to use the same blueprint for different situations. \"),mdx(\"p\",null,\"The one thing to know about classes is the \",mdx(\"inlineCode\",{parentName:\"p\"},\"dot operator\"),\" which allows us to access functions and data members of a class. When we write the variable name along with the dot operator and a function/data member, we can access that classes particular function and data member. Let's look at the following code with an example class.\"),mdx(\"pre\",e({},{className:\"language-cpp\"}),mdx(\"code\",e({parentName:\"pre\"},{className:\"language-cpp\"}),mdx(\"span\",e({parentName:\"code\"},{className:\"token keyword\"}),\"int\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"main\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),`\n    Car `,mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"myCar\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"Honda\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\",\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"Civic\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"// constructs a car with an argument\"),`\n    string make `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"=\"),\" myCar\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),\"make\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token comment\"}),\"//accesses the model data member\"),`\n    cout `,mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<<\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"This car is a \"'),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<<\"),\" make \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<<\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\" \"'),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<<\"),\" myCar\",mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\".\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token function\"}),\"model\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token operator\"}),\"<<\"),\" \",mdx(\"span\",e({parentName:\"code\"},{className:\"token string\"}),'\"\\\\n\"'),mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\";\"),` \n`,mdx(\"span\",e({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),`\n`)),mdx(\"p\",null,'The first line of code instantiates an object with the identifier \"myCar\" of the \"Car\" class. We then assume that the Car classes has a data member \"make\" which stores the make of the car, and use the dot access operator to store that in a string. Then we output that, and also use a function that returns the model of the car. '),mdx(\"h2\",e({},{id:\"templates\"}),\"Templates\"),mdx(\"p\",null,\"A majority of the classes in the C++ standard library are containers meaning they store data in a particular form. Now classes normally store data members of a set type. The people who create the container might not know what classes you make or want to code each and every type in. Instead, C++ has templates which allow for generic programming. Templates take arguments just like a function. However, they can also take a type for an argument. \"),mdx(\"p\",null,\"To use template arguments, we use angled brackets, or the less than and greater than sign to contain it. For example, there is a vector class that we will learn about later. It is a dynamically sized container, and we can specify which type it will hold by declaring it as a \",mdx(\"inlineCode\",{parentName:\"p\"},\"vector<type>\"),\" with the type insided the angled brackets. If we were to write \",mdx(\"inlineCode\",{parentName:\"p\"},\"int\"),\", then it would store integers. \"),mdx(\"h1\",e({},{id:\"array-class\"}),\"Array Class\"),mdx(\"p\",null,\"To begin, let's start with a class that does something we are quite familiar with. The Array class acts almost like a regular C++ array, but it offers some additional functionality. For example, passing it to a function will have effects more similar to thatof passing a regular variable rather than that of a regular C++ array. It will not decay into a pointer and will actually make a copy (unless you pass by  reference). \"),mdx(\"p\",null,\"To view documentation on the C++ standard library, our best friend is the website \",mdx(\"a\",e({parentName:\"p\"},{href:\"https://en.cppreference.com\"}),\"https://en.cppreference.com\"),' In the top right, they have a searchbar which we can use, and so search for \"array\". Click on the first link and we get the documentation for the array class in C++.'),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"cppstandardlibrary/arrayHeader.png\",alt:null}))),mdx(\"p\",null,\"The top of the page should look something like this. Now there's a lot of information here, and a lot of it relates to stuff that we have not learned yet. It's perfectly normal to feel overwhelmed and rather confused by all this information. There's a lot of jargon and things that you will get more and more familiar with the more you program with C++. Let's start with the first bit which says that it is defined as a \",mdx(\"inlineCode\",{parentName:\"p\"},\"template<class T, std::size_t N> struct array;\"),\". So the first thing to note is that it is a template, and it has two arguments. The first parameter says \",mdx(\"inlineCode\",{parentName:\"p\"},\"class T\"),\" which means that it takes a type for an argument. The second parameter is \",mdx(\"inlineCode\",{parentName:\"p\"},\"std::size_t N\"),\" which would take a number that tells how many elements go in the array. Then, it says that it is a \",mdx(\"inlineCode\",{parentName:\"p\"},\"struct\"),\", which functions almost identically to a class. Lastly, it just says \",mdx(\"inlineCode\",{parentName:\"p\"},\"array\"),\" which simply tells us that it is called array.\"),mdx(\"p\",null,\"Now, that's a lot of information, and a lot of it isn't obvious. However, the clear hint to most of this information is the sample code they give us which says \",mdx(\"inlineCode\",{parentName:\"p\"},\"std::aray<int, 3> a = {1, 2, 3};\"),\" which appears to be an example of how to instantiate an array. Cpp reference always has a full example of code using the class at the bottom of the page. However, it may use functions and other things that you might not be familiar with.\"),mdx(\"p\",null,\"Let's scroll down to where we see a section called \",mdx(\"inlineCode\",{parentName:\"p\"},\"Member Types\"),\".\"),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"cppstandardlibrary/arrayMember.png\",alt:null}))),mdx(\"p\",null,\"With the way classes (and in this case a struct) are usually implemented, the member variables are usually unimportant to us. We don't usually deal with them directly. So this section doesn't really tell us anything we care about to just use this class.\"),mdx(\"p\",null,\"The next section, titled \",mdx(\"inlineCode\",{parentName:\"p\"},\"Member Functions\"),\" is probably the most important section. This is where most of the functionality of the class is and that's what we need to understand to use it. The first two member functions, the constructor and destructor are special to classes. The constructor as mentioned before is used when instantiating an object of the class type. The destructor is another special function that is called when ever the object is destroyed (goes out of scope). These functions are labeled as \",mdx(\"inlineCode\",{parentName:\"p\"},\"implicitly declared\"),\" meaning that there is no implementation for them. It just uses the C++ default version which is to say it does essentially nothing.\"),mdx(\"p\",null,\"Now, the next section of functions is quite useful. It is labeled as \",mdx(\"inlineCode\",{parentName:\"p\"},\"Element Access\"),\" which tells us that these help us to access specific elements of the array. We can click on these functions to explore more about them. One of them says \",mdx(\"inlineCode\",{parentName:\"p\"},\"operator[]\"),\" which means that it used something called operator overloading. This is a functionality of classes that lets them change the behavior of certain operators. This includes the subscript operator, and things like \",mdx(\"inlineCode\",{parentName:\"p\"},\"+\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"-\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"*\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"/\"),\", and more. In this case, the subscript operator is overloaded to behave as we might expect with a regular array.\"),mdx(\"p\",null,\"Then, we get the iterators. Iterators are something that C++ containers have which allow us to traverse the elements of them. Different containers might store their data in completely different ways. Iterators allow us to traverse through the data in the same way despite the different ways they are stored. They store the address of a particular element of data and have various operators overloaded that allow us to move from one element to the next. \"),mdx(\"p\",null,\"We then have capacity functions that tell us about the elements stored in the array, and we have some operation functions that serve some functionality.\"),mdx(\"p\",null,\"After that we have \",mdx(\"inlineCode\",{parentName:\"p\"},\"Non-member Functions\"),\" and \",mdx(\"inlineCode\",{parentName:\"p\"},\"Helper Classes\"),\". These are separately implemented to change the functionality of other functions. If you need to view information about some of these particular ones, you can explore using the links provided on the website.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"headings":[{"level":1,"text":"Prerequisites","slug":"prerequisites","md":{"compiledSource":"var M=Object.defineProperty,X=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var u=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var a=(t,o,n)=>o in t?M(t,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[o]=n,r=(t,o)=>{for(var n in o||(o={}))u.call(o,n)&&a(t,n,o[n]);if(p)for(var n of p(o))s.call(o,n)&&a(t,n,o[n]);return t},y=(t,o)=>X(t,c(o));var D=(t,o)=>{var n={};for(var e in t)u.call(t,e)&&o.indexOf(e)<0&&(n[e]=t[e]);if(t!=null&&p)for(var e of p(t))o.indexOf(e)<0&&s.call(t,e)&&(n[e]=t[e]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var e=n,{components:t}=e,o=D(e,[\"components\"]);return mdx(MDXLayout,y(r(r({},layoutProps),o),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Prerequisites\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"level":2,"text":"Classes","slug":"classes","md":{"compiledSource":"var M=Object.defineProperty,X=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var u=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable;var r=(o,t,n)=>t in o?M(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n,s=(o,t)=>{for(var n in t||(t={}))u.call(t,n)&&r(o,n,t[n]);if(p)for(var n of p(t))a.call(t,n)&&r(o,n,t[n]);return o},y=(o,t)=>X(o,c(t));var D=(o,t)=>{var n={};for(var e in o)u.call(o,e)&&t.indexOf(e)<0&&(n[e]=o[e]);if(o!=null&&p)for(var e of p(o))t.indexOf(e)<0&&a.call(o,e)&&(n[e]=o[e]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var e=n,{components:o}=e,t=D(e,[\"components\"]);return mdx(MDXLayout,y(s(s({},layoutProps),t),{components:o,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Classes\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"level":2,"text":"Templates","slug":"templates","md":{"compiledSource":"var M=Object.defineProperty,X=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var a=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var s=(t,o,n)=>o in t?M(t,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[o]=n,u=(t,o)=>{for(var n in o||(o={}))a.call(o,n)&&s(t,n,o[n]);if(p)for(var n of p(o))r.call(o,n)&&s(t,n,o[n]);return t},y=(t,o)=>X(t,c(o));var D=(t,o)=>{var n={};for(var e in t)a.call(t,e)&&o.indexOf(e)<0&&(n[e]=t[e]);if(t!=null&&p)for(var e of p(t))o.indexOf(e)<0&&r.call(t,e)&&(n[e]=t[e]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var e=n,{components:t}=e,o=D(e,[\"components\"]);return mdx(MDXLayout,y(u(u({},layoutProps),o),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Templates\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}},{"level":1,"text":"Array Class","slug":"array-class","md":{"compiledSource":"var M=Object.defineProperty,X=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var e=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var u=(o,t,n)=>t in o?M(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n,a=(o,t)=>{for(var n in t||(t={}))e.call(t,n)&&u(o,n,t[n]);if(r)for(var n of r(t))s.call(t,n)&&u(o,n,t[n]);return o},y=(o,t)=>X(o,c(t));var D=(o,t)=>{var n={};for(var p in o)e.call(o,p)&&t.indexOf(p)<0&&(n[p]=o[p]);if(o!=null&&r)for(var p of r(o))t.indexOf(p)<0&&s.call(o,p)&&(n[p]=o[p]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var p=n,{components:o}=p,t=D(p,[\"components\"]);return mdx(MDXLayout,y(a(a({},layoutProps),t),{components:o,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Array Class\"))}MDXContent.isMDXComponent=!0;\n","scope":{}}}]},"__N_SSG":true}